import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class KevinBaconGame {
    private String source; // The current center of the universe
    private Graph<String, Set<String>> baconGraph; // graph for actors
    private Graph<String, Set<String>> pathTree; // path tree generated by BFS

    // constructor
    public KevinBaconGame(String source, String actorsPath, String moviesPath, String moviesActorsPath) throws Exception {
        this.source = source;
        baconGraph = new AdjacencyMapGraph<>();

        // Set up the baconGraph
        try {
            baconGraphSetter(actorMapper(actorsPath), movieMapper(moviesPath), actorMovieMapper(moviesActorsPath));
            pathTree = PsetGraphLib.bfs(baconGraph, this.source);
        } catch (Exception e) {
            System.err.println("Cannot read file: " + e.getMessage());
        }
    }

    // Creates a map of actors given ID and actor file
    public Map<Integer, String> actorMapper(String actors) throws Exception {
        Map<Integer, String> toActorMap = new HashMap<>();
        BufferedReader reader = new BufferedReader(new FileReader(actors));
        String line;

        while ((line = reader.readLine()) != null) {
            String[] parts = line.split("\\|");
            if (parts.length > 0) {
                toActorMap.put(Integer.parseInt(parts[0]), parts[1]);
            }
        }
        reader.close();
        return toActorMap;
    }

    // Creates a map of movies given ID and movie file
    public Map<Integer, String> movieMapper(String movies) throws Exception {
        Map<Integer, String> toMovieMap = new HashMap<>();
        BufferedReader reader = new BufferedReader(new FileReader(movies));
        String line;

        while ((line = reader.readLine()) != null) {
            String[] parts = line.split("\\|");
            if (parts.length > 0) {
                toMovieMap.put(Integer.parseInt(parts[0]), parts[1]);
            }
        }
        reader.close();
        return toMovieMap;
    }

    // Creates a map from movies to actor IDs
    public Map<Integer, List<Integer>> actorMovieMapper(String moviesActors) throws Exception {
        Map<Integer, List<Integer>> movieToActorMap = new HashMap<>();
        BufferedReader reader = new BufferedReader(new FileReader(moviesActors));
        String line;

        while ((line = reader.readLine()) != null) {
            String[] parts = line.split("\\|");
            if (parts.length > 0) {
                int movieId = Integer.valueOf(parts[0]);
                int actorId = Integer.valueOf(parts[1]);
                movieToActorMap.computeIfAbsent(movieId, k -> new ArrayList<>()).add(actorId);
            }
        }
        reader.close();
        return movieToActorMap;
    }

    // Builds the actor graph
    public void baconGraphSetter(Map<Integer, String> actors, Map<Integer, String> movies, Map<Integer, List<Integer>> moviesActors) {
        for (Integer actorId : actors.keySet()) {
            baconGraph.insertVertex(actors.get(actorId));
        }

        for (Integer movieId : moviesActors.keySet()) {
            String movieTitle = movies.get(movieId);
            List<Integer> actorIds = moviesActors.get(movieId);

            for (Integer actorId1 : actorIds) {
                for (Integer actorId2 : actorIds) {
                    if (!actorId1.equals(actorId2)) {
                        String actorName1 = actors.get(actorId1);
                        String actorName2 = actors.get(actorId2);
                        Set<String> edgeSet = new HashSet<>(Collections.singleton(movieTitle)); // Add movie title for the edge
                        baconGraph.insertUndirected(actorName1, actorName2, edgeSet);
                    }
                }
            }
        }
    }

    // Command interface start
    public void start() {
        // waits for user input
        Scanner scanner = new Scanner(System.in);
        System.out.println("Welcome to the Kevin Bacon Game!");
        System.out.println("Type 'help' to see available commands.");

        while (true) {
            // take command
            System.out.print("Kevin Bacon game > ");
            String command = scanner.nextLine().trim();
            processCommand(command);
        }
    }

    // scanner helper
    private void processCommand(String command) {
        // Split by the first space only to separate command from the name
        String[] tokens = command.trim().split(" ", 2);
        String cmd = tokens[0].toLowerCase(); // The command

        // Handle command processing
        switch (cmd) {
            case "help":
                displayHelp();
                break;
            case "u":
                if (tokens.length > 1) { // Check if there's a name provided
                    changeCenter(tokens[1].trim()); // Get everything after the command as the name
                } else {
                    System.out.println("Please provide a valid actor's name.");
                }
                break;
            case "p":
                if (tokens.length > 1) { // Check if there's a name provided
                    findPathToActor(tokens[1].trim()); // Get everything after the command as the name
                } else {
                    System.out.println("Please provide an actor's name.");
                }
                break;
            case "count":
                countConnectedActors();
                break;
            case "avg":
                averagePathLength();
                break;
            case "bacons":
                runBfsAndStoreResults();
                findPossibleBaconsByAverage();
                findPossibleBaconsByDegree();
                break;
            case "q":
                System.out.println("Quitting the game. Goodbye!");
                System.exit(0);
                break;
            default:
                System.out.println("Unknown command. Type 'help' for a list of commands.");
        }
    }
    // shows all of the available commands in the command terminal interface
    private void displayHelp() {
        System.out.println("Available commands:");
        System.out.println("u <name> : Change the center of the universe to <name>.");
        System.out.println("p <name> : Find the shortest path to <name> from the current center.");
        System.out.println("count     : Count actors connected to the current center.");
        System.out.println("avg       : Find the average path length to actors connected to the current center.");
        System.out.println("bacons    : Find potential Bacons based on degrees and average separations.");
        System.out.println("q         : Quit the game.");
    }
    // changes the source to a new center if present in the library
    private void changeCenter(String newCenter) {
        if (baconGraph.hasVertex(newCenter)) {
            source = newCenter;
            pathTree = PsetGraphLib.bfs(baconGraph, source);
            System.out.println("The center of the universe is now " + source + ".");
        } else {
            System.out.println("Actor '" + newCenter + "' not found in the graph.");
        }
    }
    // gets the shortest path to an actor and prints the movie that connects them
    private void findPathToActor(String actorName) {
        if(baconGraph.hasVertex(actorName) && pathTree.hasVertex(actorName)){
            List<String> shortest = PsetGraphLib.getPath(pathTree, actorName);
            String first = actorName;
            System.out.println(actorName + "'s number is " + (shortest.size() - 1));
            for(String actor : shortest){
                if(actor != first){
                    System.out.println(first + " appeared in " + baconGraph.getLabel(first, actor) + " with " + actor);
                    first = actor;
                }
            }
        }else{
            System.out.println("This actor does not exist in the shortest path");
        }
    }

    //Counts total number of vertices in the tree
    private void countConnectedActors() {
        Graph<String, Set<String>> bfsTree = PsetGraphLib.bfs(baconGraph, source);
        int count = bfsTree.numVertices();
        System.out.println("Number of actors connected to " + source + ": " + count);
    }

    // get average path length to the center
    private void averagePathLength() {
        Graph<String, Set<String>> bfsTree = PsetGraphLib.bfs(baconGraph, source);
        double average = PsetGraphLib.averageSeparation(bfsTree, source);
        System.out.println("Average path length to actors connected to " + source + ": " + average);
    }

    // Store results of BFS
    private Map<String, Integer> actorDegrees = new HashMap<>();
    private Map<String, Double> averageSeparations = new HashMap<>();

    /**
     * goes through all people, and checks if they're not in missing, then puts their avgSeparation and degrees into separate Maps
     */
    private void runBfsAndStoreResults() {
        pathTree = PsetGraphLib.bfs(baconGraph, source);
        Set<String> missing = PsetGraphLib.missingVertices(baconGraph, pathTree);
        for (String actor : baconGraph.vertices()) {
            if (!missing.contains(actor)) {
                actorDegrees.put(actor, baconGraph.outDegree(actor));
                averageSeparations.put(actor, PsetGraphLib.averageSeparation(PsetGraphLib.bfs(baconGraph, actor), actor));
            }
        }
    }

    /**
     * finds all possible bacons, ranking them in order from least out degrees to most out degrees
     */
    private void findPossibleBaconsByDegree() {
        List<Map.Entry<String, Integer>> degreeList = new ArrayList<>(actorDegrees.entrySet());
        // Sort by degree
        degreeList.sort(Map.Entry.comparingByValue());

        // Print sorted list
        System.out.println("By degree:");
        for (Map.Entry<String, Integer> entry : degreeList) {
            System.out.println(entry.getKey() + " - Degree: " + entry.getValue());
        }
    }

    /**
     * Finds all possbile bacons, ranking them in order from lowest to largest average length to center
     */
    private void findPossibleBaconsByAverage() {
        List<Map.Entry<String, Double>> averageList = new ArrayList<>(averageSeparations.entrySet());
        // Sort by average separation
        averageList.sort(Map.Entry.comparingByValue());

        // Print sorted list
        System.out.println("By average:");
        for (Map.Entry<String, Double> entry : averageList) {
            System.out.println(entry.getKey() + " - Average Separation: " + entry.getValue());
        }
    }


    public static void main(String[] args) {
        try {
            // Initialize game with file paths
            String actorsPath = "pset4/actors.txt";
            String moviesPath = "pset4/movies.txt";
            String moviesActorsPath = "pset4/movie-actors.txt";
            String initialSource = "Kevin Bacon";  // Default starting source

            KevinBaconGame game = new KevinBaconGame(initialSource, actorsPath, moviesPath, moviesActorsPath);
            game.start();
        } catch (Exception e) {
            System.err.println("Error initializing game: " + e.getMessage());
        }
    }
}