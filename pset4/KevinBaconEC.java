import java.io.IOException;
import java.util.*;

public class KevinBaconEC {
    private String source; // The current center of the universe
    private Graph<String, Set<String>> baconGraph; // graph for actors
    private Graph<String, Set<String>> pathTree; // path tree generated by BFS

    // Constructor
    public KevinBaconEC(String source, String csvFile) throws IOException {
        this.source = source;
        baconGraph = PsetGraphEC.buildGraphFromCSV(csvFile);
        pathTree = PsetGraphEC.bfs(baconGraph, this.source);
    }

    // Command interface start
    public void start() {
        // waits for user input
        Scanner scanner = new Scanner(System.in);
        System.out.println("Welcome to the Kevin Bacon Game!");
        System.out.println("Type 'help' to see available commands.");
        while (true) {
            // take command
            System.out.print("Kevin Bacon game > ");
            String command = scanner.nextLine().trim();
            processCommand(command);
        }
    }

    // Process command
    private void processCommand(String command) {
        String[] tokens = command.trim().split(" ", 2);
        String cmd = tokens[0].toLowerCase(); // The command

        switch (cmd) {
            case "help":
                displayHelp();
                break;
            case "u":
                if (tokens.length > 1) {
                    changeCenter(tokens[1].trim());
                } else {
                    System.out.println("Please provide a valid actor's name.");
                }
                break;
            case "p":
                if (tokens.length > 1) {
                    findPathToActor(tokens[1].trim());
                } else {
                    System.out.println("Please provide an actor's name.");
                }
                break;
            case "count":
                countConnectedActors();
                break;
            case "bacons":
                runBfsAndStoreResults();
                findPossibleBaconsByAverage();
                findPossibleBaconsByDegree();
                break;
            case "avg":
                averagePathLength();
                break;
            case "q":
                System.out.println("Quitting the game. Goodbye!");
                System.exit(0);
                break;
            default:
                System.out.println("Unknown command. Type 'help' for a list of commands.");
        }
    }

    // Helper functions

    private void displayHelp() {
        System.out.println("Available commands:");
        System.out.println("u <name> : Change the center of the universe to <name>.");
        System.out.println("p <name> : Find the shortest path to <name> from the current center.");
        System.out.println("count     : Count actors connected to the current center.");
        System.out.println("avg       : Find the average path length to actors connected to the current center.");
        System.out.println("q         : Quit the game.");
    }

    private void changeCenter(String newCenter) {
        if (baconGraph.hasVertex(newCenter)) {
            source = newCenter;
            pathTree = PsetGraphEC.bfs(baconGraph, source);
            System.out.println("The center of the universe is now " + source + ".");
        } else {
            System.out.println("Actor '" + newCenter + "' not found in the graph.");
        }
    }

    private void findPathToActor(String actorName) {
        if(baconGraph.hasVertex(actorName) && pathTree.hasVertex(actorName)){
            List<String> shortest = PsetGraphEC.getPath(pathTree, actorName);
            String first = actorName;
            System.out.println(actorName + "'s number is " + (shortest.size() - 1));
            for(String actor : shortest){
                if(!actor.equals(first)){
                    System.out.println(first + " appeared in " + baconGraph.getLabel(first, actor) + " with " + actor);
                    first = actor;
                }
            }
        } else {
            System.out.println("This actor does not exist in the shortest path");
        }
    }

    private void countConnectedActors() {
        Graph<String, Set<String>> bfsTree = PsetGraphEC.bfs(baconGraph, source);
        int count = bfsTree.numVertices();
        System.out.println("Number of actors connected to " + source + ": " + count);
    }

    private void averagePathLength() {
        Graph<String, Set<String>> bfsTree = PsetGraphEC.bfs(baconGraph, source);
        double average = PsetGraphEC.averageSeparation(bfsTree, source);
        System.out.println("Average path length to actors connected to " + source + ": " + average);
    }

    // Main
    public static void main(String[] args) {
        try {
            String csvFile = "pset4/actorfilms.csv";
            String initialSource = "Kevin Bacon";  // Default starting source
            KevinBaconEC game = new KevinBaconEC(initialSource, csvFile);
            game.start();
        } catch (IOException e) {
            System.err.println("Error initializing game: " + e.getMessage());
        }
    }

    private Map<String, Integer> actorDegrees = new HashMap<>();
    private Map<String, Double> averageSeparations = new HashMap<>();

    private void runBfsAndStoreResults() {
        pathTree = PsetGraphLib.bfs(baconGraph, source);
        Set<String> missing = PsetGraphLib.missingVertices(baconGraph, pathTree);
        for (String actor : baconGraph.vertices()) {
            if (!missing.contains(actor)) {
                actorDegrees.put(actor, baconGraph.outDegree(actor));
                averageSeparations.put(actor, PsetGraphLib.averageSeparation(PsetGraphLib.bfs(baconGraph, actor), actor));
            }
        }
    }

    /**
     * finds all possible bacons, ranking them in order from least out degrees to most out degrees
     */
    private void findPossibleBaconsByDegree() {
        List<Map.Entry<String, Integer>> degreeList = new ArrayList<>(actorDegrees.entrySet());
        // Sort by degree
        degreeList.sort(Map.Entry.comparingByValue());

        // Print sorted list
        System.out.println("By degree:");
        for (Map.Entry<String, Integer> entry : degreeList) {
            System.out.println(entry.getKey() + " - Degree: " + entry.getValue());
        }
    }

    /**
     * Finds all possbile bacons, ranking them in order from lowest to largest average length to center
     */
    private void findPossibleBaconsByAverage() {
        List<Map.Entry<String, Double>> averageList = new ArrayList<>(averageSeparations.entrySet());
        // Sort by average separation
        averageList.sort(Map.Entry.comparingByValue());

        // Print sorted list
        System.out.println("By average:");
        for (Map.Entry<String, Double> entry : averageList) {
            System.out.println(entry.getKey() + " - Average Separation: " + entry.getValue());
        }
    }
}